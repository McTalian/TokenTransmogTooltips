---
name: 'generate-token'
description: 'Generate Lua/XML code from the PLAN OUTPUT section of a token source record'
agent: agent
argument-hint: 'ID (3-digit record number, e.g. 001)'
---
# Generate Token Source Code

Generate the complete Lua and XML code for a new token source based on the PLAN OUTPUT section of a token record. Supports raid and non-raid token sources with different code generation patterns.

## Parameters

- `ID`: The 3-digit identifier corresponding to the token record markdown file (e.g., "001")

## Prerequisites

The token record file must contain:
- A complete and valid PLAN OUTPUT section (generated by `/plan-token`)
- Source Pattern (Standard Raid | Armor-Type Specific | Universal Token)
- Token Groups & Class Mappings
- Token ID Mappings
- Class/Difficulty/Slot appearance data

## Process

### 1. Validate ID and PLAN OUTPUT

1. Check that `ID` matches an existing file in `/.github/raid_token_records/`
2. Verify the file contains a complete PLAN OUTPUT section
3. If missing or invalid, instruct user to run `/plan-token ID="{ID}"` first

### 2. Parse PLAN OUTPUT

Extract from the PLAN OUTPUT section:
- Source name (from filename and metadata)
- Source Pattern (determines code generation strategy)
- Token group definitions and class mappings
- Token ID → Difficulty → TokenGroup → Slot mappings
- Class/Difficulty/Slot → AppearanceID → ModID data

### 3. Generate Directory Structure

Create the following directory structure:
```
TokenTransmogTooltips/Raids/{SourceName}/
  {tokengroup1}/
  {tokengroup2}/
  ...
```

> **Note**: The `Raids/` directory is used for all token sources regardless of type. This is a codebase convention, not an indication that the source must be a raid.

### 4. Generate Class Files

**For Standard Raid pattern** — each token group has named class files:

**Path**: `TokenTransmogTooltips/Raids/{SourceName}/{tokengroup}/{class}.lua`

```lua
local addonName, ns = ...
local mergeTable = ns.mergeTable

ns._Gear.{SourceName}.{CLASS} = {
  ["{DIFFICULTY}"] = {
    ["{SLOT}"] = {
      [{appearanceID}] = { {modID}, },
    },
    -- ... other slots
  },
  -- ... other difficulties
}

-- If curio/wildcard tokens exist, merge all slots into ["ALL"]
-- mergeTable(target, source) takes exactly 2 args: copies source keys into target, returns target.
-- Call it repeatedly with a local target table per difficulty.
local LOCAL_{DIFFICULTY}_GEAR = {}
mergeTable(LOCAL_{DIFFICULTY}_GEAR, ns._Gear.{SourceName}.{CLASS}["{DIFFICULTY}"]["HELM"])
mergeTable(LOCAL_{DIFFICULTY}_GEAR, ns._Gear.{SourceName}.{CLASS}["{DIFFICULTY}"]["SHOULDERS"])
mergeTable(LOCAL_{DIFFICULTY}_GEAR, ns._Gear.{SourceName}.{CLASS}["{DIFFICULTY}"]["CHEST"])
mergeTable(LOCAL_{DIFFICULTY}_GEAR, ns._Gear.{SourceName}.{CLASS}["{DIFFICULTY}"]["GAUNTLETS"])
mergeTable(LOCAL_{DIFFICULTY}_GEAR, ns._Gear.{SourceName}.{CLASS}["{DIFFICULTY}"]["LEGGINGS"])
-- ... repeat for each difficulty

ns._Gear.{SourceName}.{CLASS}["{DIFFICULTY}"]["ALL"] = LOCAL_{DIFFICULTY}_GEAR
-- ... repeat for each difficulty
```

**For Armor-Type Specific and Universal Token patterns** — each armor type has class files:

**Path**: `TokenTransmogTooltips/Raids/{SourceName}/{armortype}/{class}.lua`

```lua
local addonName, ns = ...

ns._Gear.{SourceName}.{CLASS} = {
  ["{DIFFICULTY_KEY}"] = {
    ["{SLOT}"] = {
      [{appearanceID}] = { {modID1}, {modID2}, },
    },
    -- ... other slots
  },
}
```

Where `{DIFFICULTY_KEY}` is a source-specific string (e.g., "NAZJATAR", "NZOTH_ASSAULTS", "THE_FORBIDDEN_REACH") rather than a traditional difficulty name.

**Key Requirements**:
- Use difficulty names from PLAN OUTPUT (e.g., "RAID_FINDER", "NORMAL", "HEROIC", "MYTHIC" for raids; source-specific keys for non-raids)
- Single-element arrays must use trailing comma: `{ modID, }`
- Include ALL slot if curio tokens exist
- Follow project standards for indentation and formatting

### 5. Generate Token Group Aggregators

**For Standard Raid pattern**:

**Path**: `TokenTransmogTooltips/Raids/{SourceName}/{tokengroup}/{tokengroup}.lua`

```lua
local addonName, ns = ...

local gear = ns._Gear.{SourceName}

-- Create local variables using lowercase class names
local {className1} = gear["{CLASS1}"]
local {className2} = gear["{CLASS2}"]
-- ... all classes in this token group

ns._Gear.{SourceName}["{TOKENGROUP}"] = {
  ["{DIFFICULTY}"] = {
    ["{SLOT}"] = {
      ["{CLASS1}"] = {className1}["{DIFFICULTY}"]["{SLOT}"],
      ["{CLASS2}"] = {className2}["{DIFFICULTY}"]["{SLOT}"],
      -- ... all classes
    },
    -- ... other slots
    -- If curio/wildcard tokens exist, explicitly include ["ALL"]:
    ["ALL"] = {
      ["{CLASS1}"] = {className1}["{DIFFICULTY}"]["ALL"],
      ["{CLASS2}"] = {className2}["{DIFFICULTY}"]["ALL"],
      -- ... all classes
    },
  },
  -- ... other difficulties
}
```

**For Armor-Type Specific and Universal Token patterns**:

**Path**: `TokenTransmogTooltips/Raids/{SourceName}/{armortype}/{armortype}.lua`

```lua
local addonName, ns = ...

local gear = ns._Gear.{SourceName}

-- Create local variables using lowercase class names
local {className1} = gear["{CLASS1}"]
local {className2} = gear["{CLASS2}"]
-- ... all classes

ns._Gear.{SourceName}["{ARMOR_TYPE}"] = {
  ["{DIFFICULTY_KEY}"] = {
    ["{SLOT}"] = {
      ["{CLASS1}"] = {className1}["{DIFFICULTY_KEY}"]["{SLOT}"],
      ["{CLASS2}"] = {className2}["{DIFFICULTY_KEY}"]["{SLOT}"],
      -- ... all classes in this armor type
    },
    -- ... other slots
  },
}
```

**Key Requirements**:
- Use bracket notation with string keys for class references: `gear["CLASS"]`, not `gear.CLASS`
- Create local variables for each class to improve readability
- Reference all classes in the token group / armor type
- Cover all difficulties (or single difficulty key)
- Cover all slots (including ALL if applicable)
- Use local `gear` variable for the source namespace

### 6. Generate Token Group _index.xml

For each token group (or armor type), create:

**Path**: `TokenTransmogTooltips/Raids/{SourceName}/{tokengroup}/_index.xml`

```xml
<Ui xsi:schemaLocation="http://www.blizzard.com/wow/ui/ ..\FrameXML\UI.xsd">
  <Script file="{class1}.lua"/>
  <Script file="{class2}.lua"/>
  <!-- ... all classes -->
  <!-- Aggregator last -->
  <Script file="{tokengroup}.lua"/>
</Ui>
```

**Load Order**: Classes before aggregator

### 7. Generate _index.lua

**Path**: `TokenTransmogTooltips/Raids/{SourceName}/_index.lua`

```lua
local addonName, ns = ...

ns._Gear.{SourceName} = {}
```

### 8. Generate tokens.lua

**For Standard Raid pattern**:

**Path**: `TokenTransmogTooltips/Raids/{SourceName}/tokens.lua`

Use local variables for each difficulty+group+slot combination to keep the token mapping table clean and readable. Group declarations by token group, then build the `ns.Raids` table.

```lua
local addonName, ns = ...

local mergeTable = ns.mergeTable

-- Intermediate namespace variable, then derive token group locals from it
local {source}Gear = ns._Gear.{SourceName}
local {tokengroup1}Gear = {source}Gear["{TOKENGROUP1}"]
local {tokengroup2}Gear = {source}Gear["{TOKENGROUP2}"]
-- ... all token groups

-- Pre-resolve each difficulty+group+slot into a local variable.
-- NOTE: Local variable names use shortened slot names that differ from table keys:
--   Table key "HELM"      → local var suffix _HEAD
--   Table key "SHOULDERS" → local var suffix _SHOULDERS
--   Table key "CHEST"     → local var suffix _CHEST
--   Table key "LEGGINGS"  → local var suffix _LEGS
--   Table key "GAUNTLETS" → local var suffix _HANDS
-- If the token group directory has an underscore prefix (e.g. _woven),
-- drop the underscore in local variable names (e.g. wovenGear, RAID_FINDER_WOVEN_HEAD).
local RAID_FINDER_{TOKENGROUP1}_HEAD = {tokengroup1}Gear["RAID_FINDER"]["HELM"]
local RAID_FINDER_{TOKENGROUP1}_SHOULDERS = {tokengroup1}Gear["RAID_FINDER"]["SHOULDERS"]
local RAID_FINDER_{TOKENGROUP1}_CHEST = {tokengroup1}Gear["RAID_FINDER"]["CHEST"]
local RAID_FINDER_{TOKENGROUP1}_LEGS = {tokengroup1}Gear["RAID_FINDER"]["LEGGINGS"]
local RAID_FINDER_{TOKENGROUP1}_HANDS = {tokengroup1}Gear["RAID_FINDER"]["GAUNTLETS"]
-- ... repeat for NORMAL, HEROIC, MYTHIC and each token group

-- If curio/wildcard tokens exist, declare all ALL_GEAR tables together,
-- then group all merge operations separately.
local RAID_FINDER_ALL_GEAR = {}
local NORMAL_ALL_GEAR = {}
local HEROIC_ALL_GEAR = {}
local MYTHIC_ALL_GEAR = {}

mergeTable(RAID_FINDER_ALL_GEAR, {tokengroup1}Gear["RAID_FINDER"]["ALL"])
mergeTable(RAID_FINDER_ALL_GEAR, {tokengroup2}Gear["RAID_FINDER"]["ALL"])
-- ... repeat for each token group

mergeTable(NORMAL_ALL_GEAR, {tokengroup1}Gear["NORMAL"]["ALL"])
mergeTable(NORMAL_ALL_GEAR, {tokengroup2}Gear["NORMAL"]["ALL"])
-- ... repeat for HEROIC, MYTHIC

ns.Raids.{SourceName} = {
  -- Curio token (if applicable)
  [{curioTokenID}] = {
    Difficulties = {
      [Enum.ItemCreationContext.RaidFinder] = RAID_FINDER_ALL_GEAR,
      [Enum.ItemCreationContext.RaidNormal] = NORMAL_ALL_GEAR,
      [Enum.ItemCreationContext.RaidHeroic] = HEROIC_ALL_GEAR,
      [Enum.ItemCreationContext.RaidMythic] = MYTHIC_ALL_GEAR,
    },
  },

  -- Regular tokens
  [{tokenID}] = {
    Difficulties = {
      [Enum.ItemCreationContext.RaidFinder] = RAID_FINDER_{TOKENGROUP1}_HEAD,
      [Enum.ItemCreationContext.RaidNormal] = NORMAL_{TOKENGROUP1}_HEAD,
      [Enum.ItemCreationContext.RaidHeroic] = HEROIC_{TOKENGROUP1}_HEAD,
      [Enum.ItemCreationContext.RaidMythic] = MYTHIC_{TOKENGROUP1}_HEAD,
    },
  },
  -- ... other tokens
}
```

**For Armor-Type Specific pattern** (no difficulties, separate token per armor type per slot):

```lua
local addonName, ns = ...

local mergeTable = ns.mergeTable

local clothGear = ns._Gear.{SourceName}["CLOTH"]["{DIFFICULTY_KEY}"]
local leatherGear = ns._Gear.{SourceName}["LEATHER"]["{DIFFICULTY_KEY}"]
local mailGear = ns._Gear.{SourceName}["MAIL"]["{DIFFICULTY_KEY}"]
local plateGear = ns._Gear.{SourceName}["PLATE"]["{DIFFICULTY_KEY}"]

-- If any slots have a universal token shared across all armor types
-- (e.g. a single Cloak token usable by all classes), merge all armor
-- types for that slot:
local allClassCloakGear = {}
mergeTable(allClassCloakGear, clothGear["CLOAK"])
mergeTable(allClassCloakGear, leatherGear["CLOAK"])
mergeTable(allClassCloakGear, mailGear["CLOAK"])
mergeTable(allClassCloakGear, plateGear["CLOAK"])

-- No difficulties or item creation contexts (itemContext = 0).
ns.Raids.{SourceName} = {
  -- Plate tokens
  [{tokenID}] = plateGear["{SLOT}"],
  -- Mail tokens
  [{tokenID}] = mailGear["{SLOT}"],
  -- Leather tokens
  [{tokenID}] = leatherGear["{SLOT}"],
  -- Cloth tokens
  [{tokenID}] = clothGear["{SLOT}"],
  -- Universal slot tokens (if any)
  [{tokenID}] = allClassCloakGear,
}
```

> **Note**: The universal slot merge (e.g., Cloak) is only needed when a single token maps to all armor types for that slot. Most Armor-Type Specific sources have separate tokens per armor type per slot. Only add the merge block if the PLAN OUTPUT indicates a shared token.

**For Universal Token pattern** (one token per slot, merge all armor types):

```lua
local addonName, ns = ...

local mergeTable = ns.mergeTable

local clothGear = ns._Gear.{SourceName}["CLOTH"]["{DIFFICULTY_KEY}"]
local leatherGear = ns._Gear.{SourceName}["LEATHER"]["{DIFFICULTY_KEY}"]
local mailGear = ns._Gear.{SourceName}["MAIL"]["{DIFFICULTY_KEY}"]
local plateGear = ns._Gear.{SourceName}["PLATE"]["{DIFFICULTY_KEY}"]

-- Each token is universal, merge all 4 armor types per slot.
local SLOTS = { "HELM", "SHOULDERS", "CLOAK", "CHEST", "BELT", "BRACERS", "GAUNTLETS", "LEGGINGS", "BOOTS" }
local allClassGear = {}
for _, slot in ipairs(SLOTS) do
  allClassGear[slot] = {}
  mergeTable(allClassGear[slot], clothGear[slot])
  mergeTable(allClassGear[slot], leatherGear[slot])
  mergeTable(allClassGear[slot], mailGear[slot])
  mergeTable(allClassGear[slot], plateGear[slot])
end

-- No difficulties or item creation contexts (itemContext = 0).
ns.Raids.{SourceName} = {
  [{tokenID}] = allClassGear["{SLOT}"],
  -- ... other tokens
}
```

**Key Requirements**:
- Standard Raid: Use `Enum.ItemCreationContext.*` constants (NOT numeric values)
- Armor-Type / Universal: No `Difficulties` wrapper — map token IDs directly to gear tables
- Map each token ID to correct token group/armor type, difficulty, and slot
- Handle faction-specific tokens if noted in PLAN OUTPUT
- Local variables for token groups / armor type gear tables

### 9. Generate _index.xml

**Path**: `TokenTransmogTooltips/Raids/{SourceName}/_index.xml`

**Structure**:
```xml
<Ui xsi:schemaLocation="http://www.blizzard.com/wow/ui/ ..\FrameXML\UI.xsd">
  <Script file="_index.lua"/>
  <Include file="{tokengroup1}/_index.xml"/>
  <Include file="{tokengroup2}/_index.xml"/>
  <!-- ... all token groups -->
  <Script file="tokens.lua"/>
</Ui>
```

**Load Order**: `_index.lua` → token groups → `tokens.lua`

### 10. Update _raids.xml

**Path**: `TokenTransmogTooltips/Raids/_raids.xml`

Add the new source include in the appropriate location:
- Legacy content: Alphabetical order
- Modern content (Shadowlands+): Chronological order

```xml
<Include file="{SourceName}/_index.xml"/>
```

### 11. Verification

After code generation:
1. Confirm all files were created successfully
2. Check that load order is correct in all XML files
3. For Standard Raid pattern: verify `Enum.ItemCreationContext` usage (no numeric literals)
4. For Armor-Type / Universal patterns: verify no `Difficulties` wrapper is used, tokens map directly
5. Validate single-element array syntax (trailing commas)
6. Check for any missing data or structural issues

### 12. Provide Testing Instructions

Instruct the user to:
1. Run `make build` to build the addon
2. Load into WoW (alpha build recommended for debug features)
3. Test token tooltips for each difficulty
4. Verify class icons, missing/collected status, and data accuracy
5. Refer to [.github/docs/testing-guide.md](../docs/testing-guide.md) for comprehensive checklist

## Error Handling

If any required data is missing or ambiguous:
1. **HALT IMMEDIATELY**
2. List specific issues preventing code generation
3. Reference the section/data needed
4. Instruct user to update raid record and re-run planning if needed

## Example Usage

```
/generate-token ID="002"
```

## Output

- Creates: All Lua and XML files for the new token source
- Updates: `TokenTransmogTooltips/Raids/_raids.xml`
- User receives: File creation summary and testing instructions

## Code Quality Standards

Generated code must adhere to:
- [.github/instructions/standards.instructions.md](../instructions/standards.instructions.md) - Coding conventions
- [.github/instructions/data-model.instructions.md](../instructions/data-model.instructions.md) - Data structure patterns

Key points:
- Forward slashes in file paths
- Trailing commas in all tables
- No semicolons
- 2-space indentation
- Comments explaining non-obvious logic
- Local variables for frequently referenced data
